package com.btb.relativewindcalculation;

import java.awt.Color;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import javax.imageio.ImageIO;

/**
 *
 * @author Evan Foley
 * @version 08 August 2021
 */
public class FormMain extends javax.swing.JFrame {
    private int winDiff;
    private BufferedImage img;
    private BufferedImage compass;

    /**
     * Creates new form FormMain
     */
    public FormMain() {
        initComponents();
        setLocationRelativeTo(null);
        init();
    }
    
    /**
     * Initializes the current view on startup
     */
    private void init() {
        winDiff = 0;
        try {
            img = ImageIO.read(getClass().getResourceAsStream("/images/Arrow.png"));
            compass = ImageIO.read(getClass().getResourceAsStream("/images/Plane.png"));
            pnlHeading.setImages(compass, img);
            pnlHeading.setWinDiff(winDiff);
        } catch (IOException | IllegalArgumentException e) {
            JOptionPane.showMessageDialog(this, "Could not load images needed for operation. Exiting", "Image Load Error", JOptionPane.ERROR_MESSAGE);
            System.exit(1);
        }
        lblHeadingError.setForeground(pnlMain.getBackground());
        lblWindError.setForeground(pnlMain.getBackground());
        
        // Update the initial view
        updateRelativeWind();
    }
    
    /**
     * Calculates the direction of the wind relative to the current heading
     * 
     * @param heading the current heading
     * @param windFrom the direction that the wind is coming from
     * @return negative 1 to negative 179 if wind is relative left to the heading; 0 to 180 if the wind is relative right to the heading
     */
    private int calculateRelativeWindDirection(int heading, int windFrom) {
        int max = Math.max(heading, windFrom);
        int min = Math.min(heading, windFrom);
        
        int diff = max - min;
        int mag = max == heading ? 1 : -1;
        if(diff >= 180)
        {
            return (360 - diff) * mag;
        } else
        {
            return (-diff) * mag;
        }
    }
    
    /**
     * Updates the relative wind direction
     */
    private void updateRelativeWind() {
        int heading = sldrHeading.getValue();
        int wind = sldrWind.getValue();
        winDiff = (calculateRelativeWindDirection(heading, wind) + 4) / 5 * 5;
        pnlHeading.setWinDiff(winDiff);
        String dir = "";
        
        // Only calculate if the result is not 180 or 0 degrees
        int result = winDiff;
        if (winDiff != 180 && winDiff != -180 && winDiff != 0) {
            dir = (winDiff < 0) ? "to Port" : "to Starboard";
        }
        if (result < 0) {
            result *= -1;
        }
        
        lblResult.setText("Wind direction is " + result + "\u00B0 " + dir);
        repaint();
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnlMain = new javax.swing.JPanel();
        lblheading = new javax.swing.JLabel();
        lblWindHeading = new javax.swing.JLabel();
        lblResult = new javax.swing.JLabel();
        sldrWind = new javax.swing.JSlider();
        sldrHeading = new javax.swing.JSlider();
        txtHeading = new javax.swing.JTextField();
        txtWind = new javax.swing.JTextField();
        lblHeadingError = new javax.swing.JLabel();
        lblWindError = new javax.swing.JLabel();
        pnlHeading = new com.btb.relativewindcalculation.HeadingPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Relative Wind Direction");
        setMinimumSize(new java.awt.Dimension(511, 499));
        setPreferredSize(new java.awt.Dimension(511, 499));
        setResizable(false);

        pnlMain.setBorder(javax.swing.BorderFactory.createTitledBorder("Air Data"));
        pnlMain.setPreferredSize(new java.awt.Dimension(471, 165));

        lblheading.setText("Heading:");

        lblWindHeading.setText("Wind Heading:");

        lblResult.setText("RESULT");

        sldrWind.setMaximum(359);
        sldrWind.setValue(0);
        sldrWind.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                sldrWindStateChanged(evt);
            }
        });

        sldrHeading.setMaximum(359);
        sldrHeading.setValue(0);
        sldrHeading.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                sldrHeadingStateChanged(evt);
            }
        });

        txtHeading.setText("0");
        txtHeading.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtHeadingActionPerformed(evt);
            }
        });

        txtWind.setText("0");
        txtWind.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtWindActionPerformed(evt);
            }
        });

        lblHeadingError.setForeground(new java.awt.Color(255, 0, 51));
        lblHeadingError.setText("0 - 359 only");

        lblWindError.setForeground(new java.awt.Color(255, 0, 51));
        lblWindError.setText("0 - 359 only");

        javax.swing.GroupLayout pnlMainLayout = new javax.swing.GroupLayout(pnlMain);
        pnlMain.setLayout(pnlMainLayout);
        pnlMainLayout.setHorizontalGroup(
            pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlMainLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lblResult)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlMainLayout.createSequentialGroup()
                        .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblWindHeading)
                            .addComponent(lblheading))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(sldrHeading, javax.swing.GroupLayout.DEFAULT_SIZE, 267, Short.MAX_VALUE)
                            .addComponent(sldrWind, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblHeadingError)
                            .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(txtWind, javax.swing.GroupLayout.DEFAULT_SIZE, 54, Short.MAX_VALUE)
                                .addComponent(txtHeading))
                            .addComponent(lblWindError))))
                .addContainerGap())
        );
        pnlMainLayout.setVerticalGroup(
            pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlMainLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(sldrHeading, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblheading)
                    .addComponent(txtHeading, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(4, 4, 4)
                .addComponent(lblHeadingError)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(sldrWind, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblWindHeading, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(txtWind, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblWindError)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(lblResult, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pnlHeading.setMinimumSize(new java.awt.Dimension(432, 264));
        pnlHeading.setPreferredSize(new java.awt.Dimension(432, 264));

        javax.swing.GroupLayout pnlHeadingLayout = new javax.swing.GroupLayout(pnlHeading);
        pnlHeading.setLayout(pnlHeadingLayout);
        pnlHeadingLayout.setHorizontalGroup(
            pnlHeadingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        pnlHeadingLayout.setVerticalGroup(
            pnlHeadingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 268, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(pnlHeading, javax.swing.GroupLayout.DEFAULT_SIZE, 436, Short.MAX_VALUE)
                    .addComponent(pnlMain, javax.swing.GroupLayout.DEFAULT_SIZE, 436, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(pnlMain, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(pnlHeading, javax.swing.GroupLayout.DEFAULT_SIZE, 268, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Fires when the value in the heading slider is changed
     * 
     * @param evt the event arguments
     */
    private void sldrHeadingStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_sldrHeadingStateChanged
        // TODO add your handling code here:
        txtHeading.setText(String.valueOf(sldrHeading.getValue()));
        lblHeadingError.setForeground(pnlMain.getBackground());
        updateRelativeWind();
    }//GEN-LAST:event_sldrHeadingStateChanged

    /**
     * Fires when the value in the wind slider is changed
     * 
     * @param evt the event arguments
     */
    private void sldrWindStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_sldrWindStateChanged
        // TODO add your handling code here:
        txtWind.setText(String.valueOf(sldrWind.getValue()));
        lblWindError.setForeground(pnlMain.getBackground());
        updateRelativeWind();
    }//GEN-LAST:event_sldrWindStateChanged

    /**
     * Fires when the text in the Heading text box is changed and enter is pressed
     * 
     * @param evt the event arguments
     */
    private void txtHeadingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtHeadingActionPerformed
        // TODO add your handling code here:
        textChanged(txtHeading, lblHeadingError, sldrHeading);
    }//GEN-LAST:event_txtHeadingActionPerformed
    
    /**
     * Fires when the text in the wind text box is changed and enter is pressed
     * 
     * @param evt the event arguments
     */
    private void txtWindActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtWindActionPerformed
        // TODO add your handling code here:
        textChanged(txtWind, lblWindError, sldrWind);
    }//GEN-LAST:event_txtWindActionPerformed

    /**
     * Utility method for real time text updates on GUI
     * 
     * @param jtf the JTextField that was changed
     * @param jlbl the error label that corresponds to the JTextField
     * @param jsldr the slider that corresponds to the JTextField
     */
    private void textChanged(JTextField jtf, JLabel jlbl, JSlider jsldr) {
        try {
            int heading = Integer.parseInt(jtf.getText());
            if(heading < 0 || heading > 359) {
                jlbl.setForeground(Color.RED);
                throw new NumberFormatException("Wind heading must be between 0 and 359 degrees");
            }
            jlbl.setForeground(pnlMain.getBackground());
            jsldr.setValue(heading);
        } catch(NumberFormatException e) {
            jsldr.setValue(0);
        }
        updateRelativeWind();
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch(ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException | ClassCastException e) {
            System.out.println("INFORMATIONAL: Could not set the system default look and feel. Continuing with java default");
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new FormMain().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel lblHeadingError;
    private javax.swing.JLabel lblResult;
    private javax.swing.JLabel lblWindError;
    private javax.swing.JLabel lblWindHeading;
    private javax.swing.JLabel lblheading;
    private com.btb.relativewindcalculation.HeadingPanel pnlHeading;
    private javax.swing.JPanel pnlMain;
    private javax.swing.JSlider sldrHeading;
    private javax.swing.JSlider sldrWind;
    private javax.swing.JTextField txtHeading;
    private javax.swing.JTextField txtWind;
    // End of variables declaration//GEN-END:variables
}
